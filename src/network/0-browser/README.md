# 未完成目录

+ 什么情况会阻塞页面的加载
+ 单点登陆
+ 内存泄漏与回收、垃圾回收算法
+ indexDB
+ 页面性能
+ 页面报错捕获

谈谈你对V8垃圾回收的理解？
V8引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。

分代收集：V8将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用Scavenge算法进行垃圾回收，通常采用Cheney算法，将内存分为两个半区（From Space和To Space），每次垃圾回收时，会将存活的对象复制到To Space中，并清空From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。
增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。
V8垃圾回收是对JavaScript垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。

如何优化和减少垃圾回收的影响，从而提高应用性能？
以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：

避免全局变量：全局变量不会被垃圾回收，除非它们被设置为 null。只有在确实需要时才应该使用它们。
使用对象池：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。
小心闭包：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。
手动释放大对象：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 null，从而提前提示垃圾回收器。
避免循环引用：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。
使用弱引用：在合适的场景下，使用 WeakMap 或 WeakSet 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。
优化事件监听器：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。
减少内存分配：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。
使用浏览器开发者工具：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。
考虑使用 WebAssembly：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。
